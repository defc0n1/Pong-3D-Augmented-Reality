<html>
<head>
<title>Augmented Reality Marker Detector</title>
<script type="text/javascript" src="arucojs/src/samples/getusermedia/libs/polyfill.js"></script> 
<script type="text/javascript" src="arucojs/src/cv.js"></script> 
<script type="text/javascript" src="arucojs/src/aruco.js"></script> 
<script type="text/javascript" src="threejs/src/Three.js"></script>
<script>
var video, canvas, context, imageData, detector, posit;

function onLoad(){
	video = document.getElementById("video");
	canvas = document.getElementById("canvas");
	context = canvas.getContext("2d");
	canvas.width = parseInt(canvas.style.width);
	canvas.height = parseInt(canvas.style.height);
	navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia;

	if (navigator.getUserMedia){

		function successCallback(stream){
			if (window.webkitURL) {
				video.src = window.webkitURL.createObjectURL(stream);
			} else if (video.mozSrcObject !== undefined) {
				video.mozSrcObject = stream;
			} else {
				video.src = stream;
			}
		}
		function errorCallback(error){
		}
		navigator.getUserMedia({video: true}, successCallback, errorCallback);
		detector = new AR.Detector();
		posit = new POS.Posit(modelSize, canvas.width);

		requestAnimationFrame(tick);
	}
}

function tick(){
	requestAnimationFrame(tick);
	if (video.readyState === video.HAVE_ENOUGH_DATA){
		snapshot();
		var markers = detector.detect(imageData);
		drawCorners(markers);
		drawId(markers);
	}
}

function snapshot(){
	context.drawImage(video, 0, 0, canvas.width, canvas.height);
	imageData = context.getImageData(0, 0, canvas.width, canvas.height);
}

function drawCorners(markers){
	var corners, corner, i, j;
	context.lineWidth = 3;
	for (i = 0; i !== markers.length; ++ i){

		corners = markers[i].corners;
		//Le repère de la caméra part en haut à gauche x vers la droite, y vers le bas
		// Donc on trie les markers pour les mettre dans l'ordre
		/*var permut = true;
		  while (permut) {
		  permut = false;
		  for (i = 0; i < corners.length-1; i++) {
		//Si le x de i est plus grnad que le x de i+1.
		if(corners[i].x > corners[i+1].x) {
		var val = corners[i];
		corners[i] = corners[i+1];
		corners[i+1] = val;
		permut = true;
		}
		//S'ils sont sur la meme colonne
		if (corners[i].x == corners[i+1].x) {
		//Si le y de i est plus grnad que le y de i+1.
		if(corners[i].y > corners[i+1].y) {
		var val = corners[i];
		corners[i] = corners[i+1];
		corners[i+1] = val;
		permut = true;
		}
		}		
		}
		}*/
		context.strokeStyle = "green";
		context.strokeRect(corners[0].x - 2, corners[0].y - 2, 4, 4);
		context.strokeStyle = "yellow";
		context.strokeRect(corners[1].x - 2, corners[1].y - 2, 4, 4);
		context.strokeStyle = "violet";
		context.strokeRect(corners[2].x - 2, corners[2].y - 2, 4, 4);


		context.strokeStyle = "red";
		context.beginPath();
		//On defini un chemin qui fait le tour de la cible
		var offsetx = 50;
		var offsety = 80;
		var binx = -1;
		var biny = -1;
		for (j = 0; j !== corners.length; ++ j){
			corner = corners[j];
			corner.x += offsetx*binx;
			corner.y += offsety*biny;
			if(j%2 == 0){
				offsetx *= -1;
			}
			if(j%2 ==1) {
				offsety *= -1;

			}	 
		}
		//On le trace
		
			context.moveTo(corner.x + offsetx*binx,  corner.y + offsety*biny);
			corner = corners[(j + 1) % corners.length];
			context.lineTo(corner.x  + offsetx*binx, corner.y + offsety*biny);
		pose = posit.pose(corners);
		context.stroke();
		context.closePath();
	}
}

function drawId(markers){
	var corners, corner, x, y, i, j;
	context.strokeStyle = "blue";
	context.lineWidth = 1;
	for (i = 0; i !== markers.length; ++ i){
		corners = markers[i].corners;
		x = Infinity;
		y = Infinity;
		for (j = 0; j !== corners.length; ++ j){
			corner = corners[j];
			x = Math.min(x, corner.x);
			y = Math.min(y, corner.y);
		}
		context.strokeText(markers[i].id, x, y)
	}
}

function updateObject(object, rotation, translation){

	object.scale.x = modelSize;

	object.scale.y = modelSize;

	object.scale.z = modelSize;



	object.rotation.x = -Math.asin(-rotation[1][2]);

	object.rotation.y = -Math.atan2(rotation[0][2], rotation[2][2]);

	object.rotation.z = Math.atan2(rotation[1][0], rotation[1][1]);



	object.position.x = translation[0];

	object.position.y = translation[1];

	object.position.z = -translation[2];

};



function updatePose(id, error, rotation, translation){

	var yaw = -Math.atan2(rotation[0][2], rotation[2][2]);

	var pitch = -Math.asin(-rotation[1][2]);

	var roll = Math.atan2(rotation[1][0], rotation[1][1]);



	var d = document.getElementById(id);

	d.innerHTML = " error: " + error

		+ "<br/>"

		+ " x: " + (translation[0] | 0)

		+ " y: " + (translation[1] | 0)

		+ " z: " + (translation[2] | 0)

		+ "<br/>"

		+ " yaw: " + Math.round(-yaw * 180.0/Math.PI)

		+ " pitch: " + Math.round(-pitch * 180.0/Math.PI)

		+ " roll: " + Math.round(roll * 180.0/Math.PI);

};


window.onload = onLoad;

</script>

</head>

<body style="font-family: monospace;">
<center>
<div style="margin: 10px;"><strong>-= Augmented Reality Marker Detector =-</strong></div>
<video id="video" autoplay="true" style="display:none;"></video>
<canvas id="canvas" style="width:640px; height:480px;"></canvas>
<div style="margin: 15px;"><strong>Powered by <a href="http://code.google.com/p/js-aruco/">js-aruco</a></strong></div>
</center>
</body>
</html>
